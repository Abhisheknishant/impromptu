#!/usr/bin/env bash

# We need to keep this before running any other commands.
# We check for its existence since the utils may be included multiple times.
if [[ -z "$IMPROMPTU_LAST_EXIT_CODE" ]]; then
  IMPROMPTU_LAST_EXIT_CODE=$?
fi

impromptu_ensure_constants() {
  if [[ -z "$IMPROMPTU_DIR" || ! -d "$IMPROMPTU_DIR" ]]; then
    export IMPROMPTU_DIR="$HOME/.impromptu"
  fi

  if [[ -z "$IMPROMPTU_PORT" ]]; then
    IMPROMPTU_PORT="1624"
  fi
}

# Ensures an Impromptu socket server is running.
impromptu_ensure_server() {
  compiled_dir="$IMPROMPTU_DIR/.compiled"
  pid_file="$compiled_dir/impromptu-node-server.pid"

  # Checks if the pid file exists and checks if the process is still running.
  ping_process() {
    [ -f $pid_file ] && kill -0 $(cat $pid_file) 2> /dev/null
  }

  ping_process
  if [[ "$?" -eq 0 ]]; then
    return 0
  fi

  # A server isn't running; try to start one.
  # Ensure the `.compiled` directory exists.
  [ -d $compiled_dir ] || mkdir $compiled_dir

  # Ensure the server is detached from this process and save the PID.
  (
    if [[ -n "$IMPROMPTU_UNIX_DOMAIN_SOCKET" ]]; then
      rm "$IMPROMPTU_UNIX_DOMAIN_SOCKET" &> /dev/null
      nohup "$IMPROMPTU_BIN/impromptu-node-server" $IMPROMPTU_UNIX_DOMAIN_SOCKET >& /dev/null &
    else
      nohup "$IMPROMPTU_BIN/impromptu-node-server" $IMPROMPTU_PORT >& /dev/null &
    fi
    echo "$!" > $pid_file
  )

  echo "Starting Impromptu server..."
  sleep 1

  ping_process
  if [ "$?" -eq 0 ]; then
    return 0
  else
    # The port/socket may already be in use.
    echo "Could not start Impromptu server."
    return 1
  fi
}

# Opens a connection to the Impromptu socket server.
impromptu_server_connection() {
  if [[ -n "$IMPROMPTU_UNIX_DOMAIN_SOCKET" ]]; then
    nc -w 1 -U "$IMPROMPTU_UNIX_DOMAIN_SOCKET"
  else
    nc -w 1 localhost "$IMPROMPTU_PORT"
  fi
}

# Prints the impromptu environment (including relevant local variables).
impromptu_env() {
  # Record the shell's environment.
  request_env="$(printenv)
IMPROMPTU_LAST_EXIT_CODE=$IMPROMPTU_LAST_EXIT_CODE
IMPROMPTU_JOBS_COUNT=$(jobs|wc -l|sed 's/ //g')"

  # Set the current shell.
  if [ -n "$IMPROMPTU_SHELL" ]; then
    request_env+="
IMPROMPTU_SHELL=$1"
  fi

  echo -n "$request_env"
}

# Okay, I get it. This method might look a little confusing.
# But I promise it makes sense.
#
# Both bash and zsh count color escape codes in the length of the prompt.
#
# Fortunately, both bash and zsh have a way to escape color codes in a prompt,
# so the length of the prompt can be calculated correctly. This allows you to
# do fun things like hit the up arrow or hit tab and have a normal prompt.
#
# Unfortunately, those escape codes are different. Bash ignores characters
# wrapped like "\[THIS\]", but zsh ignores stuff like "%{THIS%}". If you want
# to learn more about escape codes (have fun?), check out `src/color.coffee`.
#
# Fortunately, both bash and zsh can set commands to run right before the
# prompt is printed, which let us dynamically set the prompt.
#
# Unfortunately, there's no way for us to accurately determine which shell
# you're using (as the current shell may not be the environment `$SHELL`).
#
# But fortunately (strangely), the shells use different pre-prompt commands.
#
# So we set both commands: `PROMPT_COMMAND` for bash and `precmd` for zsh,
# and tell Impromptu to escape the color codes for that specific shell.
impromptu_set_prompt_command() {
  command="$1"
  export PROMPT_COMMAND='PS1="$(source $IMPROMPTU_BIN/'"$command"' bash)"'

  precmd() {
    export PS1="$(source $IMPROMPTU_BIN/$command zsh)"
  }
}
